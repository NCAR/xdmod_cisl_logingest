#!/usr/bin/env python
import argparse #yum install python-argparse.noarch
import os
import socket
import subprocess 
import pipes
import sys
import re
import tempfile
import shutil
import syslog
import datetime
import time
import yaml
import fcntl

def msg(*args):
    """ Send message to user """
    out = ' '.join(map(str,args)) + '\n';
    sys.stderr.write(out);
    syslog.syslog(out)
def exec_to_syslog ( cmd, cwd ):
    """ Runs cmd and places Return Value into returned list. stdout and stderror are sent to syslog  """
    if args.verbose:
        msg('Running command: %s' % cmd) 
    p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, cwd=cwd)
    stdout,stderr = p.communicate()
    for line in stdout.split("\n"):
	syslog.syslog('cmd output: %s' % (line))
    return [p.returncode, stdout ]
def exec_to_string ( cmd, cwd ):
    """ Runs cmd and places Return Value, STDOUT, STDERR into returned list  """
    if args.verbose:
        msg('Running command: %s' % cmd) 
    p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, cwd=cwd)
    stdout, stderr = p.communicate()
    return [p.returncode, stdout, stderr ]
def exec_to_string_with_input ( cmd, input, cwd):
    """ Runs cmd, sends input to STDIN and places Return Value, STDOUT, STDERR into returned list  """
    if args.verbose:
        msg('Running command: %s' % ([input, cmd])) 
    try:
        p = subprocess.Popen(cmd, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, cwd=cwd)
        stdout, stderr = p.communicate(input=input)
        return [p.returncode, stdout, stderr ]
    except:
        msg('Command %s failed' % cmd)
        return [-1, '', 'Failed to run']
 

syslog.openlog('getlsfacct')

parser = argparse.ArgumentParser(description='Cronjob to collect LSF accounting files and load them into xdmod.')
parser.add_argument('-u','--user', dest='user', help='sftp user on remote systems', required=False, default="supermod")
parser.add_argument('-b','--begintime',  dest='begintime', help='begin time of logs to collect', required=False, default="-1 day")
parser.add_argument('-e','--endtime',  dest='endtime', help='end time of logs to collect', required=False, default=time.time())
parser.add_argument('-r','--host',  dest='host', help='host to collect logs from', required=True)
parser.add_argument('-p','--path',  dest='path', help='path to accounting files on remote host', required=True)
parser.add_argument('--resources',  dest='resources', help='yaml dictonary of resource => regex EX: "{\'yellowstone\': \'/^ys/\'}"', required=True, type=yaml.load)
parser.add_argument('--email',  dest='email', help='who to email on failure', required=False, default='root')
#parser.add_argument('--tmpdir',  dest='tmpdir', help='temporary file directory', required=False, default='/var/tmp')
parser.add_argument('-v','--verbose',   dest='verbose', help='Be verbose', action="store_true", required=False)
args = parser.parse_args()

#only run with lock
LOCK = open('/var/run/getlsfacct', 'a')
fcntl.flock(LOCK.fileno(), fcntl.LOCK_EX | fcntl.LOCK_NB)

tmpdir = tempfile.mkdtemp();

try:
	ret = exec_to_string_with_input (['/usr/bin/sftp', '%s@%s' % (args.user, args.host)], 'get %s/archive.log' % (args.path), tmpdir);
	if ret[0] == 0:
		begintime   = datetime.datetime.fromtimestamp(int(args.begintime))
		endtime	    = datetime.datetime.fromtimestamp(int(args.endtime))
		msg('Begintime: %s Endtime: %s' %(begintime.strftime('%c'), endtime.strftime('%c')));
	
		#024590cb3fbd63aa5ef2fc88f6ab29a7 lsb.acct.022715.1425020461
		archive_regex = re.compile(r"""
			^(?P<hash>[a-z0-9]+)
			\s+
			(?P<file>lsb.acct.\d+.(?P<timestamp>\d+))
		""", re.VERBOSE) 
	
		with open('%s/archive.log' % (tmpdir),'r') as arcfile:
		    for line in arcfile:
	               match = archive_regex.match(line)
		       if match:
			   ts = datetime.datetime.fromtimestamp(int(match.group('timestamp')))
			   afilename = match.group('file')
			   if ts >= begintime and ts <= endtime:
			        try:
				    ret = exec_to_string_with_input (['/usr/bin/sftp', '%s@%s' % (args.user, args.host)], 'get %s/%s' % (args.path, afilename), tmpdir );
				    if ret[0] == 0:
					ret = exec_to_string_with_input (['/usr/bin/md5sum', '-c', '-'], "%s  %s/%s" % (match.group('hash'), tmpdir, afilename), tmpdir );
					if ret[0] == 0:
					    for (resname, resregex)  in args.resources.items():
						ret = exec_to_syslog (['/usr/bin/xdmod-shredder', '-v', '-r', resname, '-f', 'lsf', '-i', afilename, '--host-filter', resregex], tmpdir);
						if ret[0] != 0:
						    raise ValueError("Error: shredder failed  %s\nstderr:\n%s" % (afilename, ret[0], ret[1]))

					    ret = exec_to_syslog (['/usr/bin/xdmod-ingestor', '-v'], tmpdir);
					    if ret[0] != 0:
						raise ValueError("Error: ingestor failed  %s\nstderr:\n%s" % (afilename, ret[0], ret[1]))

					else:
					    raise ValueError("Error: bad checksum %s unable to retrieve %s\nstderr:\n%s" % (afilename, ret[0], ret[2]))
				    else:
					raise ValueError("Error: %s unable to retrieve %s\nstderr:\n%s" % (afilename, ret[0], ret[2]))
				except Exception as exception:
					msg(exception);
					ret = exec_to_string_with_input (['/bin/mail', '-s', 'getlsfacct failure', args.email], str(exception), tmpdir );

	else:
		raise ValueError("Error: %s unable to retrieve archive.log\nstderr:\n%s" % (ret[0], ret[2]))
except Exception as exception:
	msg(exception);
	ret = exec_to_string_with_input (['/bin/mail', '-s', 'getlsfacct failure', args.email], str(exception), tmpdir );

# cleanup temp dir
shutil.rmtree(tmpdir);


